<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Jewels - X·∫øp Kim C∆∞∆°ng</title>
    <style>
        :root {
            --bg-color: #0f0c29;
            --board-bg: rgba(0, 0, 0, 0.5);
            --gem-size: 45px;
            --gap: 4px;
            --board-padding: 10px;
            --highlight-color: rgba(255, 255, 255, 0.4);
            --neon-glow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 20px rgba(255, 0, 255, 0.3);
        }

        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            text-transform: uppercase;
            background: linear-gradient(to right, #00f260, #0575e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(5, 117, 230, 0.5);
            letter-spacing: 2px;
        }

        #ui-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            font-weight: bold;
            font-size: 1.1rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #game-container {
            position: relative;
            background: var(--board-bg);
            border-radius: 15px;
            padding: var(--board-padding);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* K√≠ch th∆∞·ªõc board s·∫Ω ƒë∆∞·ª£c set b·∫±ng JS */
        }

        /* L·ªõp n·ªÅn grid (c√°c √¥ tr·ªëng) */
        .grid-background {
            display: grid;
            grid-template-columns: repeat(8, var(--gem-size));
            grid-template-rows: repeat(8, var(--gem-size));
            gap: var(--gap);
        }

        .grid-cell {
            width: var(--gem-size);
            height: var(--gem-size);
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
        }

        /* L·ªõp ch·ª©a c√°c vi√™n kim c∆∞∆°ng (n·∫±m ƒë√® l√™n background) */
        #gem-layer {
            position: absolute;
            top: var(--board-padding);
            left: var(--board-padding);
            width: calc(100% - 2 * var(--board-padding));
            height: calc(100% - 2 * var(--board-padding));
            pointer-events: none; /* ƒê·ªÉ click xuy√™n qua xu·ªëng background n·∫øu c·∫ßn, nh∆∞ng ta s·∫Ω x·ª≠ l√Ω click ri√™ng */
        }

        .gem {
            position: absolute;
            width: var(--gem-size);
            height: var(--gem-size);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--gem-size) * 0.7);
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s, filter 0.2s;
            border-radius: 50%;
            /* Quan tr·ªçng cho animation di chuy·ªÉn */
            transition-property: top, left, transform, opacity, filter;
            transition-duration: 0.3s;
            transition-timing-function: ease-in-out;
            z-index: 10;
            
            /* Hi·ªáu ·ª©ng b√≥ng b·∫©y */
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2), transparent);
            box-shadow: inset 0 0 5px rgba(255,255,255,0.1);
        }

        .gem:hover {
            filter: brightness(1.2);
            transform: scale(1.05);
        }

        .gem.selected {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px #fff, inset 0 0 10px #fff;
            animation: pulse 1s infinite;
            z-index: 20;
        }

        .gem.matched {
            transform: scale(0);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* N√∫t ƒëi·ªÅu khi·ªÉn */
        .btn {
            margin-top: 20px;
            padding: 10px 25px;
            font-size: 1.1rem;
            background: linear-gradient(45deg, #ff0099, #493240);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 0, 153, 0.4);
            transition: transform 0.1s, box-shadow 0.2s;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(255, 0, 153, 0.4);
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px #ff0099;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        .pop-text {
            animation: popUp 1s ease-out forwards;
        }

        @keyframes popUp {
            0% { opacity: 0; transform: translate(-50%, -20%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(1); }
        }

        /* Mobile Responsive */
        @media (max-width: 500px) {
            :root {
                --gem-size: 11vw;
                --gap: 2px;
                --board-padding: 5px;
            }
            h1 { font-size: 1.8rem; }
            #ui-container { margin-bottom: 10px; }
        }
    </style>
</head>
<body>

    <h1>Neon Jewels</h1>
    
    <div id="ui-container">
        <div class="stat-box">ƒêi·ªÉm: <span id="score">0</span></div>
        <div class="stat-box">Combo: <span id="combo">0</span></div>
    </div>

    <div id="game-container">
        <div class="grid-background" id="grid-bg">
            </div>
        <div id="gem-layer">
            </div>
        <div id="message"></div>
    </div>

    <button class="btn" onclick="startGame()">Game M·ªõi</button>

    <script>
        const ROWS = 8;
        const COLS = 8;
        const GEMS = ["üíé", "üî¥", "üî∂", "üíö", "üíú", "üåô", "‚ùÑÔ∏è"]; // Th√™m icon cho ƒë·∫πp
        
        let grid = []; // L∆∞u tr·ªØ d·ªØ li·ªáu logic (ch·ª©a object gem)
        let score = 0;
        let selectedGem = null;
        let isProcessing = false; // Kh√≥a b√†n c·ªù khi ƒëang animation
        let comboCount = 0;

        // L·∫•y k√≠ch th∆∞·ªõc th·ª±c t·∫ø t·ª´ CSS ƒë·ªÉ t√≠nh to√°n v·ªã tr√≠ tuy·ªát ƒë·ªëi
        // S·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi resize ho·∫∑c start game
        let GEM_SIZE_PX = 0;
        let GAP_PX = 0;

        const gemLayer = document.getElementById("gem-layer");
        const gridBg = document.getElementById("grid-bg");
        const scoreEl = document.getElementById("score");
        const comboEl = document.getElementById("combo");
        const msgEl = document.getElementById("message");

        // --- C·∫§U TR√öC D·ªÆ LI·ªÜU ---
        class Gem {
            constructor(r, c, type) {
                this.r = r;
                this.c = c;
                this.type = type;
                this.el = document.createElement("div");
                this.el.className = "gem";
                this.el.textContent = type;
                this.el.onclick = () => handleGemClick(this);
                
                // Set v·ªã tr√≠ ban ƒë·∫ßu (c√≥ th·ªÉ s·∫Ω c·∫≠p nh·∫≠t sau)
                this.updatePosition();
                gemLayer.appendChild(this.el);
            }

            updatePosition() {
                // T√≠nh to√°n v·ªã tr√≠ left/top d·ª±a tr√™n r, c
                const left = this.c * (GEM_SIZE_PX + GAP_PX);
                const top = this.r * (GEM_SIZE_PX + GAP_PX);
                this.el.style.left = `${left}px`;
                this.el.style.top = `${top}px`;
            }

            moveTo(r, c) {
                this.r = r;
                this.c = c;
                this.updatePosition();
            }

            destroy() {
                this.el.classList.add("matched");
                setTimeout(() => {
                    if (this.el.parentNode) {
                        this.el.parentNode.removeChild(this.el);
                    }
                }, 300); // Kh·ªõp v·ªõi transition CSS
            }
        }

        // --- INIT & SETUP ---

        function initMetrics() {
            // L·∫•y gi√° tr·ªã t·ª´ CSS variable ƒë√£ t√≠nh to√°n (responsive)
            const computedStyle = getComputedStyle(document.documentElement);
            // M·ªôt ch√∫t hack ƒë·ªÉ l·∫•y gi√° tr·ªã pixel ch√≠nh x√°c t·ª´ grid-cell ƒë·∫ßu ti√™n n·∫øu c√≥
            const tempCell = document.createElement("div");
            tempCell.className = "grid-cell";
            gridBg.appendChild(tempCell);
            GEM_SIZE_PX = tempCell.offsetWidth;
            gridBg.removeChild(tempCell);
            
            // Gap c√≥ th·ªÉ l·∫•y g·∫ßn ƒë√∫ng ho·∫∑c fix c·ª©ng v√¨ CSS d√πng gap pixel
            // Tr√™n mobile gap nh·ªè h∆°n
            GAP_PX = window.innerWidth <= 500 ? 2 : 4;
        }

        function startGame() {
            gemLayer.innerHTML = "";
            gridBg.innerHTML = "";
            grid = [];
            score = 0;
            scoreEl.innerText = "0";
            comboCount = 0;
            comboEl.innerText = "0";
            isProcessing = false;
            selectedGem = null;

            initMetrics();
            createGridBackground();
            
            // T·∫°o m·∫£ng 2 chi·ªÅu
            for (let r = 0; r < ROWS; r++) {
                let row = [];
                for (let c = 0; c < COLS; c++) {
                    row.push(null);
                }
                grid.push(row);
            }

            // ƒêi·ªÅn gem v√† ƒë·∫£m b·∫£o kh√¥ng c√≥ match s·∫µn
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    let type;
                    do {
                        type = GEMS[Math.floor(Math.random() * GEMS.length)];
                    } while (
                        (c >= 2 && grid[r][c-1].type === type && grid[r][c-2].type === type) ||
                        (r >= 2 && grid[r-1][c].type === type && grid[r-2][c].type === type)
                    );
                    grid[r][c] = new Gem(r, c, type);
                }
            }
        }

        function createGridBackground() {
            for(let i=0; i<64; i++) {
                const cell = document.createElement("div");
                cell.className = "grid-cell";
                gridBg.appendChild(cell);
            }
        }

        // --- GAME LOGIC ---

        function handleGemClick(gem) {
            if (isProcessing) return;

            if (!selectedGem) {
                // Ch·ªçn vi√™n ƒë·∫ßu ti√™n
                select(gem);
            } else if (selectedGem === gem) {
                // B·ªè ch·ªçn
                deselect();
            } else {
                // Ch·ªçn vi√™n th·ª© 2 -> ki·ªÉm tra k·ªÅ nhau
                if (isAdjacent(selectedGem, gem)) {
                    attemptSwap(selectedGem, gem);
                } else {
                    // Ch·ªçn vi√™n kh√°c kh√¥ng k·ªÅ -> chuy·ªÉn v√πng ch·ªçn
                    deselect();
                    select(gem);
                }
            }
        }

        function select(gem) {
            selectedGem = gem;
            gem.el.classList.add("selected");
        }

        function deselect() {
            if (selectedGem) {
                selectedGem.el.classList.remove("selected");
                selectedGem = null;
            }
        }

        function isAdjacent(g1, g2) {
            return Math.abs(g1.r - g2.r) + Math.abs(g1.c - g2.c) === 1;
        }

        async function attemptSwap(g1, g2) {
            isProcessing = true;
            deselect(); // X√≥a highlight

            // Ho√°n ƒë·ªïi v·ªã tr√≠ trong logic
            swapData(g1, g2);
            
            // Animation ho√°n ƒë·ªïi
            g1.updatePosition();
            g2.updatePosition();

            // Ch·ªù animation ch·∫°y xong (0.3s)
            await wait(300);

            // Ki·ªÉm tra match
            const matches = findMatches();

            if (matches.length > 0) {
                // Th√†nh c√¥ng
                comboCount = 0; // Reset combo cho l∆∞·ª£t ƒëi ch·ªß ƒë·ªông
                await processMatches(matches);
            } else {
                // Th·∫•t b·∫°i -> ƒë·ªïi l·∫°i
                swapData(g1, g2);
                g1.updatePosition();
                g2.updatePosition();
                await wait(300);
                isProcessing = false;
            }
        }

        function swapData(g1, g2) {
            // Swap coords
            const tr = g1.r; const tc = g1.c;
            g1.r = g2.r; g1.c = g2.c;
            g2.r = tr; g2.c = tc;
            
            // Swap trong grid
            grid[g1.r][g1.c] = g1;
            grid[g2.r][g2.c] = g2;
        }

        function findMatches() {
            let matchedSet = new Set();

            // Check ngang
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS - 2; c++) {
                    let g1 = grid[r][c], g2 = grid[r][c+1], g3 = grid[r][c+2];
                    if (g1.type === g2.type && g2.type === g3.type) {
                        matchedSet.add(g1); matchedSet.add(g2); matchedSet.add(g3);
                    }
                }
            }

            // Check d·ªçc
            for (let c = 0; c < COLS; c++) {
                for (let r = 0; r < ROWS - 2; r++) {
                    let g1 = grid[r][c], g2 = grid[r+1][c], g3 = grid[r+2][c];
                    if (g1.type === g2.type && g2.type === g3.type) {
                        matchedSet.add(g1); matchedSet.add(g2); matchedSet.add(g3);
                    }
                }
            }

            return Array.from(matchedSet);
        }

        async function processMatches(matches) {
            comboCount++;
            comboEl.innerText = comboCount;
            
            // T√≠nh ƒëi·ªÉm: (s·ªë l∆∞·ª£ng * 10) * combo
            const points = matches.length * 10 * comboCount;
            score += points;
            scoreEl.innerText = score;

            // Hi·ªÉn th·ªã text ƒëi·ªÉm th∆∞·ªüng n·∫øu combo cao
            if (comboCount > 1) {
                showFloatingText(`Combo x${comboCount}!`);
            } else if (matches.length >= 4) {
                showFloatingText("Tuy·ªát v·ªùi!");
            }

            // X√≥a gem
            matches.forEach(g => {
                g.destroy();
                grid[g.r][g.c] = null; // ƒê√°nh d·∫•u √¥ tr·ªëng
            });

            await wait(300); // Ch·ªù hi·ªáu ·ª©ng n·ªï

            await applyGravity();
        }

        async function applyGravity() {
            // D·ªìn c√°c vi√™n c√≤n l·∫°i xu·ªëng d∆∞·ªõi
            for (let c = 0; c < COLS; c++) {
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (grid[r][c] === null) {
                        // T√¨m vi√™n g·∫ßn nh·∫•t ·ªü tr√™n ƒë·ªÉ k√©o xu·ªëng
                        for (let k = r - 1; k >= 0; k--) {
                            if (grid[k][c] !== null) {
                                // Di chuy·ªÉn logic
                                let gem = grid[k][c];
                                grid[r][c] = gem;
                                grid[k][c] = null;
                                // Di chuy·ªÉn hi·ªÉn th·ªã
                                gem.moveTo(r, c);
                                break;
                            }
                        }
                    }
                }
            }

            // Ch·ªù c√°c vi√™n r∆°i xu·ªëng xong
            await wait(300);

            // T·∫°o vi√™n m·ªõi ·ªü c√°c √¥ tr·ªëng (t·ª´ tr√™n r∆°i xu·ªëng ·∫£o gi√°c)
            await fillNewGems();
        }

        async function fillNewGems() {
            let moves = [];
            for (let c = 0; c < COLS; c++) {
                for (let r = 0; r < ROWS; r++) {
                    if (grid[r][c] === null) {
                        let type = GEMS[Math.floor(Math.random() * GEMS.length)];
                        let gem = new Gem(r, c, type);
                        
                        // ƒê·∫∑t v·ªã tr√≠ xu·∫•t ph√°t ·ªü tr√™n n√≥c b√†n c·ªù ƒë·ªÉ r∆°i xu·ªëng
                        gem.el.style.top = `-${GEM_SIZE_PX}px`;
                        // Force reflow ƒë·ªÉ tr√¨nh duy·ªát nh·∫≠n v·ªã tr√≠ b·∫Øt ƒë·∫ßu
                        gem.el.offsetHeight; 
                        
                        // C·∫≠p nh·∫≠t v·ªã tr√≠ ƒë√≠ch
                        gem.updatePosition();
                        
                        grid[r][c] = gem;
                    }
                }
            }

            await wait(300); // Ch·ªù r∆°i xong

            // ƒê·ªá quy ki·ªÉm tra match m·ªõi
            const newMatches = findMatches();
            if (newMatches.length > 0) {
                await processMatches(newMatches);
            } else {
                isProcessing = false; // K·∫øt th√∫c chu·ªói
            }
        }

        // --- UTILS ---
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function showFloatingText(text) {
            msgEl.innerText = text;
            msgEl.className = ""; // Reset anim
            void msgEl.offsetWidth; // Trigger reflow
            msgEl.className = "pop-text";
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            initMetrics();
            // C·∫≠p nh·∫≠t l·∫°i v·ªã tr√≠ t·∫•t c·∫£ gem ƒëang c√≥
            grid.forEach(row => {
                row.forEach(gem => {
                    if(gem) gem.updatePosition();
                })
            })
        });

        // Start
        startGame();

    </script>
</body>
</html>