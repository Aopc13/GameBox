<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slither.io Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #161c22;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #scoreBoard {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
        }

        #score {
            font-size: 24px;
            font-weight: bold;
        }

        #leaderboard {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            min-width: 150px;
        }

        #leaderboard h3 {
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 16px;
            color: #ccc;
        }

        #leaderList {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 14px;
        }

        #leaderList li {
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .my-score {
            color: #fff !important;
            font-weight: bold;
        }

        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        h1 {
            color: #fff;
            font-size: 60px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #a29bfe;
            font-weight: 300;
            letter-spacing: 2px;
        }

        input {
            padding: 15px 20px;
            font-size: 18px;
            border-radius: 30px;
            border: none;
            outline: none;
            width: 300px;
            text-align: center;
            margin-bottom: 20px;
            background: #fff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        input:focus {
            transform: scale(1.05);
        }

        button.play-btn {
            padding: 15px 50px;
            font-size: 20px;
            border-radius: 30px;
            border: none;
            cursor: pointer;
            background: linear-gradient(45deg, #00b894, #00cec9);
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button.play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 101;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .controls-hint {
            margin-top: 30px;
            color: #aaa;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="ui">
            <div id="scoreBoard">
                <span>Length: </span><span id="score">10</span>
            </div>
            <div id="leaderboard">
                <h3>Leaderboard</h3>
                <ul id="leaderList"></ul>
            </div>
        </div>

        <div id="startMenu">
            <h1>Slither.io Clone</h1>
            <input type="text" id="nickname" placeholder="Nickname" maxlength="12">
            <button class="play-btn" onclick="startGame()">Play</button>
            <div class="controls-hint">
                Mouse to move â€¢ Click/Space to boost
            </div>
        </div>

        <div id="gameOver">
            <h2 style="font-size: 40px; margin-bottom: 10px;">Game Over</h2>
            <p>Final Length: <span id="finalScore">0</span></p>
            <button class="play-btn" onclick="resetGame()" style="margin-top: 20px;">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const WORLD_SIZE = 4000;
        const INITIAL_LENGTH = 10;
        const BASE_RADIUS = 10;
        const SPEED = 5;
        const BOOST_SPEED = 12;
        const ROTATION_SPEED = 0.1;
        const FOOD_COUNT = 1000;
        const BOT_COUNT = 20;

        // Game State
        let gameRunning = false;
        let lastTime = 0;
        let camX = 0, camY = 0;
        let mouseX = 0, mouseY = 0;
        let boosting = false;
        let scale = 1;

        // Entities
        let snake;
        let bots = [];
        let foods = [];
        let particles = [];

        // Colors
        const SNAKE_COLORS = [
            ['#ff7675', '#d63031'], // Red
            ['#55efc4', '#00b894'], // Green
            ['#74b9ff', '#0984e3'], // Blue
            ['#a29bfe', '#6c5ce7'], // Purple
            ['#ffeaa7', '#fdcb6e'], // Yellow
            ['#ff9ff3', '#fd79a8'], // Pink
            ['#fab1a0', '#e17055']  // Orange
        ];

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            add(v) { return new Vector(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
            mult(n) { return new Vector(this.x * n, this.y * n); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const m = this.mag();
                return m === 0 ? new Vector(0, 0) : new Vector(this.x / m, this.y / m);
            }
        }

        class Food {
            constructor(x, y, value = 1) {
                this.pos = new Vector(x || Math.random() * WORLD_SIZE, y || Math.random() * WORLD_SIZE);
                this.value = value;
                this.radius = 5 + Math.sqrt(value) * 2;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.glowing = Math.random() > 0.8;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = this.glowing ? 15 : 0;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Snake {
            constructor(x, y, isBot = false, name = '') {
                this.pos = new Vector(x, y);
                this.angle = Math.random() * Math.PI * 2;
                this.targetAngle = this.angle;
                this.points = [];
                this.length = INITIAL_LENGTH;
                this.radius = BASE_RADIUS;
                this.isBot = isBot;
                this.name = name || (isBot ? 'Bot ' + Math.floor(Math.random() * 1000) : 'Player');
                this.colors = SNAKE_COLORS[Math.floor(Math.random() * SNAKE_COLORS.length)];
                this.speed = SPEED;
                this.dead = false;
                this.score = 0;

                // Initialize body segments
                for (let i = 0; i < this.length * 5; i++) {
                    this.points.push(new Vector(x, y));
                }
            }

            update() {
                if (this.dead) return;

                // Handle Input/AI
                if (this.isBot) {
                    this.updateBotAI();
                } else {
                    // Player follows mouse
                    const mouseWorldX = mouseX / scale + camX;
                    const mouseWorldY = mouseY / scale + camY;
                    const dx = mouseWorldX - this.pos.x;
                    const dy = mouseWorldY - this.pos.y;
                    this.targetAngle = Math.atan2(dy, dx);

                    if (boosting && this.length > 10) {
                        this.speed = BOOST_SPEED;
                        // Drop mass while boosting
                        if (Math.random() < 0.2) {
                            this.length -= 0.1;
                            this.score = Math.floor((this.length - INITIAL_LENGTH) * 10);
                            dropFood(this.points[this.points.length - 1], 0.5);
                        }
                    } else {
                        this.speed = SPEED;
                    }
                }

                // Smooth rotation
                let diff = this.targetAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += Math.max(-ROTATION_SPEED, Math.min(ROTATION_SPEED, diff));

                // Move head
                const velocity = new Vector(Math.cos(this.angle), Math.sin(this.angle)).mult(this.speed);
                this.pos = this.pos.add(velocity);

                // Boundary check
                if (this.pos.x < 0 || this.pos.x > WORLD_SIZE || this.pos.y < 0 || this.pos.y > WORLD_SIZE) {
                    this.die();
                }

                // Update body segments
                this.points.unshift(this.pos);

                // Limit body length based on score
                // We store more points than visible length to make movement smooth
                const targetPoints = Math.floor(this.length * 5);
                while (this.points.length > targetPoints) {
                    this.points.pop();
                }

                // Update radius based on length
                this.radius = BASE_RADIUS + Math.sqrt(this.length) * 0.5;
            }

            updateBotAI() {
                // Initialize AI state if missing
                if (!this.aiState) {
                    this.aiState = {
                        turnDirection: Math.random() < 0.5 ? 1 : -1,
                        wanderAngle: this.angle,
                        wanderTimer: 0
                    };
                }

                // 1. Collision Avoidance (Highest Priority)
                const lookAheadDist = this.radius * 4 + 60;
                const lookX = this.pos.x + Math.cos(this.angle) * lookAheadDist;
                const lookY = this.pos.y + Math.sin(this.angle) * lookAheadDist;

                let danger = false;

                // Check boundaries
                if (lookX < 50 || lookX > WORLD_SIZE - 50 || lookY < 50 || lookY > WORLD_SIZE - 50) {
                    danger = true;
                }

                // Check snakes
                if (!danger) {
                    const allSnakes = [...bots, snake].filter(s => s && s !== this && !s.dead);
                    for (const s of allSnakes) {
                        for (let i = 0; i < s.points.length; i += 6) {
                            const p = s.points[i];
                            const d = Math.hypot(p.x - lookX, p.y - lookY);
                            if (d < s.radius + this.radius + 40) {
                                danger = true;
                                break;
                            }
                        }
                        if (danger) break;
                    }
                }

                if (danger) {
                    // Turn constantly in one direction until clear
                    this.targetAngle += 0.3 * this.aiState.turnDirection;
                    this.speed = SPEED;
                    return; // Focus solely on avoiding
                }

                // 2. Food Seeking
                let nearestFood = null;
                let minDist = Infinity;

                // Scan for food nearby
                for (const food of foods) {
                    const dx = food.pos.x - this.pos.x;
                    const dy = food.pos.y - this.pos.y;

                    // Optimization: Quick bounding box check
                    if (Math.abs(dx) > 300 || Math.abs(dy) > 300) continue;

                    const d = Math.hypot(dx, dy);
                    if (d < 300 && d < minDist) {
                        minDist = d;
                        nearestFood = food;
                    }
                }

                if (nearestFood) {
                    this.targetAngle = Math.atan2(nearestFood.pos.y - this.pos.y, nearestFood.pos.x - this.pos.x);

                    // Boost if food is close and safe
                    if (minDist > 50 && minDist < 200 && this.length > 20) {
                        this.speed = BOOST_SPEED;
                    } else {
                        this.speed = SPEED;
                    }
                } else {
                    // 3. Wandering (Smoother)
                    this.speed = SPEED;

                    this.aiState.wanderTimer--;
                    if (this.aiState.wanderTimer <= 0) {
                        // Pick a new general direction occasionally
                        this.aiState.wanderAngle = this.angle + (Math.random() - 0.5) * 2;
                        this.aiState.wanderTimer = 50 + Math.random() * 100;
                        // Randomize turn direction for next avoidance
                        this.aiState.turnDirection = Math.random() < 0.5 ? 1 : -1;
                    }

                    // Slowly steer towards wander angle
                    this.targetAngle = this.aiState.wanderAngle;
                }
            }

            draw(ctx) {
                if (this.dead) return;

                // Draw Body
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw outline
                // We draw segments with spacing to simulate the slither style
                const spacing = 5;

                for (let i = this.points.length - 1; i >= 0; i -= spacing) {
                    const p = this.points[i];
                    // Gradient effect from head to tail
                    ctx.fillStyle = (i < 10) ? this.colors[1] : this.colors[0];

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw Eyes
                const eyeOffset = this.radius * 0.6;
                const eyeSize = this.radius * 0.4;
                const head = this.pos;

                const leftEye = new Vector(
                    head.x + Math.cos(this.angle - 0.5) * eyeOffset,
                    head.y + Math.sin(this.angle - 0.5) * eyeOffset
                );
                const rightEye = new Vector(
                    head.x + Math.cos(this.angle + 0.5) * eyeOffset,
                    head.y + Math.sin(this.angle + 0.5) * eyeOffset
                );

                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(leftEye.x, leftEye.y, eyeSize, 0, Math.PI * 2);
                ctx.arc(rightEye.x, rightEye.y, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(leftEye.x + Math.cos(this.angle) * 2, leftEye.y + Math.sin(this.angle) * 2, eyeSize * 0.5, 0, Math.PI * 2);
                ctx.arc(rightEye.x + Math.cos(this.angle) * 2, rightEye.y + Math.sin(this.angle) * 2, eyeSize * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Draw Name
                if (this.isBot || true) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.name, head.x, head.y - this.radius - 10);
                }
            }

            eat(amount) {
                this.length += amount;
                this.score = Math.floor((this.length - INITIAL_LENGTH) * 10);
                if (!this.isBot) {
                    document.getElementById('score').innerText = this.score;
                    // Grow animation or particle effect could go here
                }
            }

            die() {
                this.dead = true;
                // Convert body to food
                for (let i = 0; i < this.points.length; i += 3) {
                    dropFood(this.points[i], 1);
                }

                if (!this.isBot) {
                    showGameOver();
                } else {
                    // Respawn bot
                    setTimeout(() => {
                        bots = bots.filter(b => b !== this);
                        bots.push(new Snake(Math.random() * WORLD_SIZE, Math.random() * WORLD_SIZE, true));
                    }, 1000);
                }
            }
        }

        function dropFood(pos, value) {
            foods.push(new Food(pos.x + (Math.random() - 0.5) * 20, pos.y + (Math.random() - 0.5) * 20, value));
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Input
            window.addEventListener('mousemove', e => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            window.addEventListener('mousedown', () => boosting = true);
            window.addEventListener('mouseup', () => boosting = false);
            window.addEventListener('keydown', e => {
                if (e.code === 'Space') boosting = true;
            });
            window.addEventListener('keyup', e => {
                if (e.code === 'Space') boosting = false;
            });

            // Init Food
            for (let i = 0; i < FOOD_COUNT; i++) {
                foods.push(new Food());
            }

            // Init Bots
            for (let i = 0; i < BOT_COUNT; i++) {
                bots.push(new Snake(Math.random() * WORLD_SIZE, Math.random() * WORLD_SIZE, true));
            }

            requestAnimationFrame(loop);
        }

        function startGame() {
            const name = document.getElementById('nickname').value || 'Player';
            snake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, false, name);
            document.getElementById('startMenu').style.display = 'none';
            gameRunning = true;
        }

        function resetGame() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startMenu').style.display = 'flex';
            // Clean up old snake
            snake = null;
        }

        function showGameOver() {
            gameRunning = false;
            document.getElementById('finalScore').innerText = snake.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function checkCollisions() {
            if (!snake || snake.dead) return;

            // Snake vs Food
            for (let i = foods.length - 1; i >= 0; i--) {
                const f = foods[i];
                if (Math.hypot(f.pos.x - snake.pos.x, f.pos.y - snake.pos.y) < snake.radius + f.radius) {
                    snake.eat(f.value * 0.1);
                    foods.splice(i, 1);
                    foods.push(new Food()); // Respawn food immediately elsewhere
                }
            }

            // Bots vs Food
            bots.forEach(bot => {
                if (bot.dead) return;
                for (let i = foods.length - 1; i >= 0; i--) {
                    const f = foods[i];
                    if (Math.hypot(f.pos.x - bot.pos.x, f.pos.y - bot.pos.y) < bot.radius + f.radius) {
                        bot.eat(f.value * 0.1);
                        foods.splice(i, 1);
                        foods.push(new Food());
                    }
                }
            });

            // Snake vs Bots (Collision)
            // Check if Player hits Bot Body
            bots.forEach(bot => {
                if (bot.dead) return;

                // Player hits Bot
                for (let i = 0; i < bot.points.length; i += 2) {
                    const p = bot.points[i];
                    if (Math.hypot(p.x - snake.pos.x, p.y - snake.pos.y) < snake.radius + bot.radius * 0.8) {
                        snake.die();
                        return;
                    }
                }

                // Bot hits Player
                for (let i = 0; i < snake.points.length; i += 2) {
                    const p = snake.points[i];
                    if (Math.hypot(p.x - bot.pos.x, p.y - bot.pos.y) < bot.radius + snake.radius * 0.8) {
                        bot.die();
                        snake.eat(bot.length * 0.5); // Bonus for killing
                    }
                }
            });
        }

        function drawGrid(ctx) {
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            const gridSize = 50;

            const startX = Math.floor(camX / gridSize) * gridSize;
            const startY = Math.floor(camY / gridSize) * gridSize;
            const endX = startX + canvas.width / scale + gridSize;
            const endY = startY + canvas.height / scale + gridSize;

            ctx.beginPath();
            for (let x = startX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }
            for (let y = startY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }
            ctx.stroke();

            // Draw World Border
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);
        }

        function updateLeaderboard() {
            const list = document.getElementById('leaderList');
            list.innerHTML = '';

            const all = [...bots];
            if (snake && !snake.dead) all.push(snake);

            all.sort((a, b) => b.score - a.score);

            all.slice(0, 5).forEach((s, i) => {
                const li = document.createElement('li');
                li.innerHTML = `<span>#${i + 1} ${s.name}</span> <span>${s.score}</span>`;
                if (s === snake) li.className = 'my-score';
                list.appendChild(li);
            });
        }

        function loop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;

            // Clear
            ctx.fillStyle = '#161c22';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameRunning && snake && !snake.dead) {
                // Update Camera
                // Smooth camera follow
                const targetCamX = snake.pos.x - canvas.width / 2 / scale;
                const targetCamY = snake.pos.y - canvas.height / 2 / scale;
                // Increase lerp speed slightly for better responsiveness
                camX += (targetCamX - camX) * 0.1;
                camY += (targetCamY - camY) * 0.1;

                // Update Logic
                snake.update();
                bots.forEach(b => b.update());
                checkCollisions();

                // Update Leaderboard occasionally
                if (Math.floor(timestamp / 1000) % 2 === 0) updateLeaderboard();
            } else if (!gameRunning && snake) {
                // Keep camera on dead snake for a moment or just center
            }

            // Draw World
            ctx.save();
            ctx.scale(scale, scale);
            ctx.translate(-camX, -camY);

            drawGrid(ctx);

            // Draw food first (below snakes)
            foods.forEach(f => f.draw(ctx));

            // Draw bots
            bots.forEach(b => b.draw(ctx));

            // Draw player last (on top)
            if (snake && !snake.dead) snake.draw(ctx);

            ctx.restore();

            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>

</html>